import com.sun.tools.javac.Main;
/**

 O - позволяет сравнить количество операций в худшем случае

 0(log n) - логарифмическое время (бинарный поиск)
 O(n) - линейное время (простой поиск)
 0(n* log n) - эффективные алгоритмы сортировки (быстрая сортировка)
 O(n^2) - медленные алгороитмы сортировки - сортировка выбором
 0(n!) - очень медленные алгоритмы (задача о коммивояжере)

 Задача о коммивояжеоре -все возможные варианты обьезда городов (n!)

В общем случае дл списка из n элементов бинарный поиск
выполняется за log2(n) шагов, тогда как простой поиск будет
выполняться за n шагов.

 С бинарным поиском каждый раз загадывается число в середине диапазона исключаете половину оставшихся чисел

 например, в массиве 240 к элементов.
 1. Простой поиск худший результат - 240 000 попыток
 2. Бинарный поиск - 18 шагов (2 в степени 18 = 262 144, в степени 17 = 131 072) т.е. log2 24000 = 18

 Бинарный поиск работает только если список отсортирован


 Например, массив из 8 элементов:
 1. простой поиск O(n): = 8 шагов
 2. Бинарный поиск O(log n): log2 8 = 3 шага, т.е. log (n)

 Например, массив из 16 элементов:
 1. Простой поиск O(n) = 16 шагов
 2. Бинарный оиск O(log n): log2 16 = 4 шага

                  простой поиск | бинарный поиск
------------------------------------------------
 100 элементов     100 мс              7 мс
 10 000            10 с                14 мс
 1 000 000         11 дней             32 мс


*/

public class binary {
    // write your code here
//

    //7
    //3



public static void finder(int []b, int x){
    int low = b[0];
    int top = b.length - 1;
    long log = Math.round(Math.log(16)/Math.log(2));




     for (int foo=1; foo<=log+1; foo++) {
        int center = ((low + top)) / 2;
        System.out.println("low: "+low + " top: " + top + " middle: " + center+":" + "item: " +b[center]+" лог. с основ 2: "+log);
        if (x!=b[center]) {

            if (x < b[center]) {
                top = center;
                center = (center + top) / 2;
            } else {
                low = center;
                center = (center + low) / 2;
            }

        }else{
            break;
        }


    }
}





    public static void main(String[] args) {
        // write your code here
        int[] b = {0,1,3,4,5,7,8,9,10,11,12,13,14,15,16,17,18,19,20,30,32,33,35,38};
        binary.finder(b,1);
    }
}